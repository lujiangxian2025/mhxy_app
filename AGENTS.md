# 游戏助手 Android App 架构文档

## 架构概览

```
game_assistant_app/
├── docs/                           # 设计文档归档
│   ├── MOBILE_APP_DESIGN.md       # 完整设计文档（现象→本质→哲学）
│   ├── WIREFRAMES.md              # 线框图与交互流程
│   ├── IMPLEMENTATION_GUIDE.md    # 技术实现指南
│   └── API_MAPPING.md             # API 接口映射（对接 game_assistant）
│
└── [待创建] app/                   # Android 项目源码
    ├── ui/                        # UI 层：纯展示，无业务逻辑
    ├── data/                      # 数据层：API + 本地存储
    ├── domain/                    # 业务逻辑层：领域模型 + 用例
    └── di/                        # 依赖注入：模块解耦
```

---

## 后端对接

**服务端**：`game_assistant/src/app_server.py`（FastAPI）  
**API 文档**：`http://<server_ip>:8000/docs`

### API 端点映射

| App 功能 | API 端点 | 方法 |
|----------|----------|------|
| 健康检查 | `/` | GET |
| 应用列表 | `/app_list` | GET |
| 创建应用 | `/app_create` | POST |
| 销毁应用 | `/app_destroy` | POST |
| 暂停任务 | `/app_msg` | POST |
| 恢复任务 | `/app_msg` | POST |
| 执行动作 | `/app_action` | POST |
| 动作状态 | `/action_status` | GET |
| 应用配置 | `/app_configs` | CRUD |
| 任务配置 | `/task_configs` | CRUD |

### 动作类型（AppAction）

```
APP_INIT           - 应用初始化
OPEN_GAME_ACTION   - 打开游戏
INIT_ACTION        - 初始化
APP_RESET_WINDOW_ACTION - 重置窗口
CATCH_GHOST_ACTION - 捉鬼任务
FLYING_THIEF_ACTION - 飞贼任务
BP_TRADE_ACTION    - 跑商任务
```

### 消息类型（AppMsg）

```
APP_GAME_PAUSE     - 暂停游戏
APP_GAME_RESUME    - 恢复游戏
APP_BIND_WINDOW    - 绑定窗口
APP_UNBIND_WINDOW  - 解绑窗口
```

---

## 设计哲学

### 现象层：用户痛点
**场景**：通勤路上远程控制家中服务器  
**约束**：时间碎片化、网络不稳定、单手操作、小屏幕  
**目标**：3 秒看状态、5 秒启动任务、10 秒改配置

### 本质层：架构决策
**信息架构**：3 个核心 Tab（首页/任务/设置），扁平化导航  
**状态管理**：单向数据流（ViewModel + StateFlow），单一真相源  
**网络策略**：乐观更新 + 错误回滚，5 秒轮询（可升级 WebSocket）  
**交互模式**：底部 Tab（拇指热区）+ 卡片化（信息聚合）+ 手势操作（左滑停止/右滑启动）

### 哲学层：设计真理
1. **信息的呼吸感**：不塞满屏幕，让关键信息自然呼吸（卡片间距 16dp）
2. **操作的确定性**：触觉反馈 + 长按确认 + 骨架屏，移动环境下的确定性
3. **单手的优雅**：拇指热区是第一约束，核心操作在屏幕下半部分
4. **极简的克制**：每个屏幕只解决一个问题，消除不必要的复杂性

---

## 技术架构

### 技术栈
- **UI 框架**：Jetpack Compose（声明式 UI，代码即设计）
- **状态管理**：ViewModel + StateFlow（单向数据流）
- **网络层**：Retrofit + OkHttp（成熟稳定）
- **依赖注入**：Hilt（简化依赖管理）
- **本地存储**：DataStore（类型安全，协程友好）

### 分层设计
```
UI 层（ui/）
  ↓ 调用
Domain 层（domain/）
  ↓ 调用
Data 层（data/）
  ↓ 调用
API 服务器
```

**职责边界**：
- UI 层：展示数据，收集输入，无业务逻辑
- Domain 层：业务逻辑，领域模型，用例编排
- Data 层：API 调用，数据映射，本地存储

---

## 核心设计决策

### 决策 1：Compose 而非 XML
**理由**：声明式 UI，代码简洁，状态驱动，易于维护  
**哲学**：UI = f(State)，消除命令式更新的复杂性

### 决策 2：单向数据流
**理由**：状态可预测，调试容易，避免状态混乱  
**哲学**：数据如河流般单向流动，时间不可逆

### 决策 3：乐观更新
**理由**：立即反馈，提升体验，失败时回滚  
**哲学**：信任用户操作，网络延迟不应阻塞 UI

### 决策 4：轮询而非 WebSocket
**理由**：实现简单，延迟可接受（本地网络），易于调试  
**哲学**：实用主义优先，过度工程是敌人

### 决策 5：2 Tab 导航（简化架构）
**理由**：任务 Tab 的功能可被首页和详情页完全吸收，无独立存在理由  
**哲学**：奥卡姆剃刀——如无必要，勿增实体。能消失的 Tab 永远比能写对的 Tab 更优雅

---

## 屏幕设计

### 1. 首页（Dashboard）
**职责**：状态总览，快速操作  
**元素**：服务器状态 + 应用卡片列表 + 创建应用入口  
**交互**：点击卡片 → 详情页，点击启动 → 任务选择器

### 2. 应用详情（App Detail）
**职责**：单个应用的完整信息与控制  
**元素**：应用状态 + 当前任务 + 配置快捷修改 + 停止按钮  
**交互**：点击参数 → 弹出编辑器，长按停止 → 二次确认

### 3. 设置（Settings）
**职责**：配置管理 + 低频操作  
**元素**：服务器配置 + 配置模板管理 + 历史记录 + 关于  
**交互**：开关切换，跳转子页面

---

## 交互流程

### 启动任务（5 秒完成）
```
首页 → 点击"启动任务" → Bottom Sheet 选择类型 
→ 乐观更新（立即显示"启动中"）→ API 调用 
→ 成功：刷新列表 + Toast / 失败：回滚 + 重试按钮
```

### 修改配置（10 秒完成）
```
详情页 → 点击参数 ✏️ → Dialog 数字键盘 
→ 输入新值 → 乐观更新 → API 调用 
→ 成功：Toast / 失败：回滚 + Toast
```

### 停止任务（防误触）
```
详情页 → 长按"停止任务"（1 秒）→ 触觉反馈 
→ 确认对话框（显示任务信息）→ 点击确认 
→ 乐观更新 → API 调用 → Toast
```

---

## 代码品味

### 好品味：状态用枚举，消除分支
```kotlin
enum class AppStatus { RUNNING, STOPPED, ERROR }

@Composable
fun StatusBadge(status: AppStatus) {
    val (text, color) = when (status) {
        RUNNING -> "● 运行中" to Green
        STOPPED -> "○ 已停止" to Gray
        ERROR -> "✖️ 错误" to Red
    }
    Text(text, color = color)
}
```

### 坏品味：字符串判断，分支爆炸
```kotlin
// ❌ 不要这样写
if (status == "running") { ... }
else if (status == "stopped") { ... }
else if (status == "error") { ... }
else { ... } // 特殊情况又来了
```

### 好品味：单向数据流，状态可预测
```kotlin
// UI 只读取状态，不修改状态
val uiState by viewModel.uiState.collectAsState()

// 所有状态变更通过 ViewModel
viewModel.startTask(virtualName, action, params)
```

### 坏品味：UI 直接修改状态
```kotlin
// ❌ 不要这样写
var apps by remember { mutableStateOf(emptyList()) }
apps = apps + newApp // UI 层修改状态，混乱之源
```

---

## 性能优化

### 网络优化
- 请求合并：首页一次请求获取所有应用状态
- 缓存策略：状态数据缓存 5 秒，减少请求
- 超时控制：移动网络超时 10 秒

### UI 优化
- 懒加载：历史记录分页加载
- 骨架屏：加载时显示占位符，避免白屏
- 图标优化：使用矢量图（SVG），减少体积

### 电量优化
- 轮询间隔：前台 5 秒，后台 30 秒
- 网络监听：无网络时停止轮询
- 唤醒锁：避免不必要的屏幕唤醒

---

## 开发路线图

### Phase 1：MVP（2 周）
- ✅ 首页：应用列表 + 状态展示
- ✅ 应用详情：任务信息 + 快速操作
- ✅ 网络层：API 调用封装
- ✅ 基础交互：启动/停止任务

### Phase 2：完善功能（1 周）
- ⏳ 任务中心：运行中任务 + 快速启动
- ⏳ 配置编辑：参数修改 + 验证
- ⏳ 设置页：服务器配置 + 通知

### Phase 3：体验优化（1 周）
- ⏳ 乐观更新：立即反馈 + 错误回滚
- ⏳ 触觉反馈：按钮震动 + 长按确认
- ⏳ 骨架屏：加载占位符

### Phase 4：高级功能（可选）
- 🔔 推送通知：任务完成 + 错误警报
- 📊 数据统计：任务效率分析
- 🌙 暗黑模式：夜间友好

---

## 文档结构

### MOBILE_APP_DESIGN.md
**职责**：完整设计文档，从现象到哲学的三层分析  
**内容**：用户痛点、交互架构、设计原则、屏幕设计、技术选型

### WIREFRAMES.md
**职责**：可视化线框图，交互流程图  
**内容**：所有屏幕的 ASCII 线框图、状态变化图、手势交互图

### IMPLEMENTATION_GUIDE.md
**职责**：技术实现指南，可直接编码  
**内容**：项目初始化、模块结构、核心代码、依赖注入、构建配置

### API_MAPPING.md
**职责**：后端 API 接口映射文档  
**内容**：所有 API 端点、请求/响应格式、数据模型映射、错误处理  
**数据来源**：`game_assistant/src/api_*.py`

---

## 变更日志

### 2026-02-05 (v1.1) - 简化为 2 Tab 架构
- ✅ 移除任务中心页面（Task Center）
- ✅ 功能重新分配：运行中任务 → 首页，快速启动 → 详情页，历史记录 → 设置页
- ✅ 导航简化：3 Tab → 2 Tab（首页 / 设置）
- ✅ 更新所有设计文档
- **设计哲学**：能消失的 Tab 永远比能写对的 Tab 更优雅

### 2026-02-05 (v1.0) - 初始设计
- ✅ 完成三层架构分析（现象→本质→哲学）
- ✅ 完成信息架构设计
- ✅ 完成交互流程设计（启动/停止/配置）
- ✅ 完成技术选型（Compose + Hilt + Retrofit）
- ✅ 完成线框图设计
- ✅ 完成实现指南（可直接编码）
- ✅ 完成 API 接口映射（对接 game_assistant）
- ✅ 创建架构文档（AGENTS.md）

---

## 设计哲学总结

**极简不是删除，而是让每个元素都有存在的理由。**

这个 App 的设计遵循三个永恒真理：
1. **信息的呼吸感**：不塞满屏幕，让关键信息自然呼吸
2. **操作的确定性**：移动环境下，用户需要明确知道"我点了什么"
3. **单手的优雅**：拇指热区是设计的第一约束

代码即设计，架构即哲学。每一个交互决策都是对用户场景的深刻理解，每一行代码都是对简洁性的追求。

**简化是最高形式的复杂。**

---

**架构设计者**：Kiro AI Assistant  
**文档版本**：v1.0  
**创建时间**：2026-02-05
